<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Brown Hu | JavaScript继承新旧方法汇总</title>
    <meta name="description" content="Replace the stars and rivers in the body with unlimited methods for the future.">
    <link rel="icon" href="/BrownHu/head.jpg">
    
    <link rel="preload" href="/BrownHu/assets/css/0.styles.442cca43.css" as="style"><link rel="preload" href="/BrownHu/assets/js/app.a914753b.js" as="script"><link rel="preload" href="/BrownHu/assets/js/32.ca616d80.js" as="script"><link rel="prefetch" href="/BrownHu/assets/js/22.a329b40f.js"><link rel="prefetch" href="/BrownHu/assets/js/1.8fa0e60a.js"><link rel="prefetch" href="/BrownHu/assets/js/2.12fa4220.js"><link rel="prefetch" href="/BrownHu/assets/js/3.6d5d5df6.js"><link rel="prefetch" href="/BrownHu/assets/js/4.76d86bcd.js"><link rel="prefetch" href="/BrownHu/assets/js/5.c0749ed0.js"><link rel="prefetch" href="/BrownHu/assets/js/6.e1f46d70.js"><link rel="prefetch" href="/BrownHu/assets/js/7.9ef3a889.js"><link rel="prefetch" href="/BrownHu/assets/js/8.a8c44d39.js"><link rel="prefetch" href="/BrownHu/assets/js/9.18dc3270.js"><link rel="prefetch" href="/BrownHu/assets/js/10.63c7a93a.js"><link rel="prefetch" href="/BrownHu/assets/js/11.78e21786.js"><link rel="prefetch" href="/BrownHu/assets/js/12.e4c5e876.js"><link rel="prefetch" href="/BrownHu/assets/js/13.f53ab6ff.js"><link rel="prefetch" href="/BrownHu/assets/js/14.014630a1.js"><link rel="prefetch" href="/BrownHu/assets/js/15.debbbcf5.js"><link rel="prefetch" href="/BrownHu/assets/js/16.4f6293a0.js"><link rel="prefetch" href="/BrownHu/assets/js/17.df1d58fe.js"><link rel="prefetch" href="/BrownHu/assets/js/18.3af2c419.js"><link rel="prefetch" href="/BrownHu/assets/js/19.28d6b0ac.js"><link rel="prefetch" href="/BrownHu/assets/js/20.edc80dfc.js"><link rel="prefetch" href="/BrownHu/assets/js/21.46e45c82.js"><link rel="prefetch" href="/BrownHu/assets/js/23.951da821.js"><link rel="prefetch" href="/BrownHu/assets/js/24.2e9bf580.js"><link rel="prefetch" href="/BrownHu/assets/js/25.4032ada3.js"><link rel="prefetch" href="/BrownHu/assets/js/26.2c5a3afb.js"><link rel="prefetch" href="/BrownHu/assets/js/27.1c0f83cb.js"><link rel="prefetch" href="/BrownHu/assets/js/28.bba50489.js"><link rel="prefetch" href="/BrownHu/assets/js/29.ac32ff33.js"><link rel="prefetch" href="/BrownHu/assets/js/30.c183c77c.js"><link rel="prefetch" href="/BrownHu/assets/js/31.a21c239b.js"><link rel="prefetch" href="/BrownHu/assets/js/33.323673dc.js"><link rel="prefetch" href="/BrownHu/assets/js/34.c6788753.js"><link rel="prefetch" href="/BrownHu/assets/js/35.afbf7d21.js"><link rel="prefetch" href="/BrownHu/assets/js/36.0f89f2d8.js"><link rel="prefetch" href="/BrownHu/assets/js/37.b34a44dc.js"><link rel="prefetch" href="/BrownHu/assets/js/38.4719b6a7.js"><link rel="prefetch" href="/BrownHu/assets/js/39.da27343c.js"><link rel="prefetch" href="/BrownHu/assets/js/40.0f7d2ba5.js"><link rel="prefetch" href="/BrownHu/assets/js/41.81a8be31.js"><link rel="prefetch" href="/BrownHu/assets/js/42.5c6392e8.js"><link rel="prefetch" href="/BrownHu/assets/js/43.da1f6789.js"><link rel="prefetch" href="/BrownHu/assets/js/44.a072b540.js">
    <link rel="stylesheet" href="/BrownHu/assets/css/0.styles.442cca43.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/BrownHu/" class="home-link router-link-active"><!----><span class="site-name">
      Brown Hu
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/BrownHu/blog/" class="nav-link router-link-active">Blog</a></div><div class="nav-item"><a href="/BrownHu/config/" class="nav-link">Project</a></div><div class="nav-item"><a href="/BrownHu/default-theme-config/" class="nav-link">Resume</a></div><a href="https://github.com/hubingliang/BrownHu/" target="_blank" rel="noopener noreferrer" class="github-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/BrownHu/blog/" class="nav-link router-link-active">Blog</a></div><div class="nav-item"><a href="/BrownHu/config/" class="nav-link">Project</a></div><div class="nav-item"><a href="/BrownHu/default-theme-config/" class="nav-link">Resume</a></div><a href="https://github.com/hubingliang/BrownHu/" target="_blank" rel="noopener noreferrer" class="github-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>JavaScript</span><span class="arrow up"></span></p><ul class="sidebar-group-items"><li><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html" class="active sidebar-link">JavaScript继承新旧方法汇总</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#例子" class="sidebar-link">例子</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#简单的原型链" class="sidebar-link">简单的原型链</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#借用构造函数" class="sidebar-link">借用构造函数</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#组合继承（伪经典继承）" class="sidebar-link">组合继承（伪经典继承）</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#原型式" class="sidebar-link">原型式</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#寄生式" class="sidebar-link">寄生式</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#寄生组合继承" class="sidebar-link">寄生组合继承</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#es5使用-object-create-创建对象" class="sidebar-link">ES5使用 Object.create 创建对象</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#es6使用-class-关键字" class="sidebar-link">ES6使用 class 关键字</a></li><li class="sidebar-sub-header"><a href="/BrownHu/blog/JavaScript/JavaScript继承新旧方法汇总.html#参考文献" class="sidebar-link">参考文献</a></li></ul></li><li><a href="/BrownHu/blog/JavaScript/JavaScript的三种事件模型.html" class="sidebar-link">JavaScript的三种事件模型</a></li><li><a href="/BrownHu/blog/JavaScript/使用原生JS实现事件委托.html" class="sidebar-link">使用原生JS实现事件委托</a></li><li><a href="/BrownHu/blog/JavaScript/this到底指向哪里？.html" class="sidebar-link">this到底指向哪里？</a></li><li><a href="/BrownHu/blog/JavaScript/吃透ES6-let和const.html" class="sidebar-link">吃透ES6----let和const</a></li><li><a href="/BrownHu/blog/JavaScript/吃透ES6-简洁优雅的箭头函数.html" class="sidebar-link">吃透ES6----简洁优雅的箭头函数</a></li><li><a href="/BrownHu/blog/JavaScript/学会了ES6，就不会写出那样的代码.html" class="sidebar-link">学会了ES6，就不会写出那样的代码</a></li><li><a href="/BrownHu/blog/JavaScript/排序算法-N个正整数排序.html" class="sidebar-link">排序算法-N个正整数排序</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>HTTP</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Library</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Other</span><span class="arrow down"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Wheel</span><span class="arrow down"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="javascript继承新旧方法汇总"><a href="#javascript继承新旧方法汇总" aria-hidden="true" class="header-anchor">#</a> JavaScript继承新旧方法汇总</h1><h2 id="例子"><a href="#例子" aria-hidden="true" class="header-anchor">#</a> 例子</h2><p>我们生成两个构造函数，后面的例子都是让‘’猫‘’继承‘’动物‘’的所有属性和方法。</p><ul><li>动物(为了更好的理解各种继承，这里给动物附上了基本类型和引用类型)</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">do</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
<span class="token punctuation">}</span>
</code></pre><ul><li>猫</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
<span class="token punctuation">}</span>
</code></pre><h2 id="简单的原型链"><a href="#简单的原型链" aria-hidden="true" class="header-anchor">#</a> 简单的原型链</h2><p>这可能是最简单直观的一种实现继承方式了</p><h3 id="实现方法"><a href="#实现方法" aria-hidden="true" class="header-anchor">#</a> 实现方法</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">do</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
<span class="token punctuation">}</span>　　
<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
<span class="token punctuation">}</span>
Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span> <span class="token comment">//重点！！！！！</span>
Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小黄'</span><span class="token punctuation">,</span> <span class="token string">'黄色'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">// 动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">// [ '运动', '繁殖' ] </span>
</code></pre><h3 id="核心"><a href="#核心" aria-hidden="true" class="header-anchor">#</a> 核心</h3><p>这种方法的核心就这一句话：Cat.prototype = new Animal 也就是拿父类实例来充当子类原型对象</p><h3 id="优缺点"><a href="#优缺点" aria-hidden="true" class="header-anchor">#</a> 优缺点</h3><p>然而这个方法虽然简单但是有一个很严重的问题：在我们修改一个实例的属性时，其他的也随之改变。</p><pre class="language-js"><code><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小黄'</span><span class="token punctuation">,</span> <span class="token string">'黄色'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小白'</span><span class="token punctuation">,</span> <span class="token string">'白色'</span><span class="token punctuation">)</span>
cat1<span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">'哺乳动物'</span>
cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'呼吸'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">// 哺乳动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat2<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">// 动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">// [ '运动', '繁殖', '呼吸' ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat2<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">// [ '运动', '繁殖', '呼吸' ]</span>
</code></pre><ul><li>优点</li></ul><ol><li>容易实现</li></ol><ul><li>缺点
<ol><li><p>修改cat1.do后cat2.do也变了，因为来自原型对象的引用属性是所有实例共享的。
可以这样理解：执行cat1.do.push('呼吸');先对cat1进行属性查找，找遍了实例属性（在本例中没有实例属性），没找到，就开始顺着原型链向上找，拿到了cat1的原型对象，一搜身，发现有do属性。于是给do末尾插入了'呼吸'，所以sub2.do也变了</p></li><li><p>创建子类实例时，无法向父类构造函数传参</p></li></ol></li></ul><h3 id="继承链的紊乱问题"><a href="#继承链的紊乱问题" aria-hidden="true" class="header-anchor">#</a> 继承链的紊乱问题</h3><pre class="language-js"><code>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span>
</code></pre><p>任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有&quot;Cat.prototype = new Animal();&quot;这一行，Cat.prototype.constructor是指向Cat的。加了这一行以后，Cat.prototype.constructor指向Animal。</p><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Animal<span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre><p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。因此，在运行&quot;Cat.prototype = new Animal();&quot;这一行之后，cat1.constructor也指向Animal！</p><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><p>这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。</p><pre class="language-js"><code>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat
</code></pre><p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。</p><h2 id="借用构造函数"><a href="#借用构造函数" aria-hidden="true" class="header-anchor">#</a> 借用构造函数</h2><p>使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：Animal.apply(this, arguments)</p><h3 id="实现方法-2"><a href="#实现方法-2" aria-hidden="true" class="header-anchor">#</a> 实现方法</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">do</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
<span class="token punctuation">}</span>　　
<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　
    Animal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span> <span class="token comment">///重点！！！！</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
<span class="token punctuation">}</span>
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小黄'</span><span class="token punctuation">,</span> <span class="token string">'黄色'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">// 动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">// [ '运动', '繁殖' ] </span>
</code></pre><h3 id="核心-2"><a href="#核心-2" aria-hidden="true" class="header-anchor">#</a> 核心</h3><p>借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）</p><h3 id="优缺点-2"><a href="#优缺点-2" aria-hidden="true" class="header-anchor">#</a> 优缺点</h3><pre class="language-js"><code><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小黄'</span><span class="token punctuation">,</span> <span class="token string">'黄色'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小白'</span><span class="token punctuation">,</span> <span class="token string">'白色'</span><span class="token punctuation">)</span>
cat1<span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">'哺乳动物'</span>
cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'呼吸'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">// 哺乳动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat2<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">// 动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">// [ '运动', '繁殖', '呼吸' ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat2<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">// [ '运动', '繁殖' ]</span>
</code></pre><ul><li>优点：</li></ul><ol><li>解决了子类实例共享父类引用属性的问题</li><li>创建子类实例时，可以向父类构造函数传参</li></ol><ul><li>缺点：</li></ul><ol><li>无法实现函数复用，过多的占用内存。</li><li>创建子类实例时，无法向父类构造函数传参</li></ol><h2 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" aria-hidden="true" class="header-anchor">#</a> 组合继承（伪经典继承）</h2><p>将原型链和借用构造函数的技术组合起来，发挥二者之长：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义的方法实现了函数复用，又能够保证每个实例都有它自己的属性。是实现继承最常用的方式。</p><h3 id="实现方法-3"><a href="#实现方法-3" aria-hidden="true" class="header-anchor">#</a> 实现方法</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">do</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
<span class="token punctuation">}</span>　　
<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　
    Animal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token comment">//重点！！！！</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
<span class="token punctuation">}</span>
Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token comment">//重点！！！！</span>
Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小黄'</span><span class="token punctuation">,</span> <span class="token string">'黄色'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">// 动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">// [ '运动', '繁殖' ] </span>
</code></pre><h3 id="核心-3"><a href="#核心-3" aria-hidden="true" class="header-anchor">#</a> 核心</h3><p>把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过Animal.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Cat.prototype = new Animal继承父类函数，实现函数复用。</p><h3 id="优缺点-3"><a href="#优缺点-3" aria-hidden="true" class="header-anchor">#</a> 优缺点</h3><ul><li>优点：</li></ul><ol><li>不存在引用属性共享问题</li><li>可传参</li><li>函数可复用</li></ol><ul><li>缺点:</li></ul><ol><li>子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份。(私有属性一份，原型里面一份)</li></ol><h2 id="原型式"><a href="#原型式" aria-hidden="true" class="header-anchor">#</a> 原型式</h2><p>道格拉斯·克罗克福德在2006年写了一篇文章，Prototypal Inheritance in JavaScript(JavaScript中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型，为了达到这个目的，他给出了如下函数。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    f<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅拷贝。</p><h3 id="实现方法-4"><a href="#实现方法-4" aria-hidden="true" class="header-anchor">#</a> 实现方法</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">do</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
<span class="token punctuation">}</span>　
<span class="token keyword">var</span> Animal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span>　
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>Animal1<span class="token punctuation">)</span><span class="token comment">//重点！！！！</span>

cat1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'小黄'</span>
cat1<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'黄色'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">//动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">//[&quot;运动&quot;, &quot;繁殖&quot;]</span>
</code></pre><h3 id="核心-4"><a href="#核心-4" aria-hidden="true" class="header-anchor">#</a> 核心</h3><p>核心就是通过一个函数来得到一个空的新对象，再在空对象的基础上添加需要的方法（实例属性）</p><h3 id="优缺点-4"><a href="#优缺点-4" aria-hidden="true" class="header-anchor">#</a> 优缺点</h3><ul><li>优点：</li></ul><ol><li>从已有对象衍生新对象，不需要创建自定义类型。</li></ol><ul><li>缺点:</li></ul><ol><li>原型引用属性会被所有实例共享，因为是用整个父类对象来充当了子类
原型对象，所以这个缺陷无可避免</li><li>无法实现代码复用</li></ol><h2 id="寄生式"><a href="#寄生式" aria-hidden="true" class="header-anchor">#</a> 寄生式</h2><p>寄生式在我看来和原型式差别不大，只是把对空对象私有属性的添加封装成了一个函数。</p><h3 id="实现方法-5"><a href="#实现方法-5" aria-hidden="true" class="header-anchor">#</a> 实现方法</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">do</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
<span class="token punctuation">}</span>　
<span class="token keyword">function</span> <span class="token function">getCatObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//重点！！！！</span>
    clone<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'小黄'</span>
    clone<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'黄色'</span>
    <span class="token keyword">return</span> clone
<span class="token punctuation">}</span>

<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token function">getCatObject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">//动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">//[&quot;运动&quot;, &quot;繁殖&quot;]</span>
</code></pre><h3 id="核心-5"><a href="#核心-5" aria-hidden="true" class="header-anchor">#</a> 核心</h3><p>只是给原型式继承套了一个壳子而已。
对于寄生式的理解：创建新对象 -&gt; 增强 -&gt; 返回该对象，这样的过程叫寄生式继承，新对象是如何创建的并不重要。</p><h3 id="优缺点-5"><a href="#优缺点-5" aria-hidden="true" class="header-anchor">#</a> 优缺点</h3><ul><li>优点：</li></ul><ol><li>不需要创建自定义类型。</li></ol><ul><li>缺点:</li></ul><ol><li>无法实现代码复用</li></ol><h2 id="寄生组合继承"><a href="#寄生组合继承" aria-hidden="true" class="header-anchor">#</a> 寄生组合继承</h2><p>前面说过，组合继承是JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。也就是会出现这种情况：
<img src="http://upload-images.jianshu.io/upload_images/4337988-038d15a750ee3e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>
我们发现在私有属性和原型里面都有name和do的属性，这是因为调用了两次构造函数造成的后果，这必然会过多占用内存。
寄生组合继承完美的解决了这个问题。</p><h3 id="实现方法-6"><a href="#实现方法-6" aria-hidden="true" class="header-anchor">#</a> 实现方法</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　
    <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">do</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
<span class="token punctuation">}</span>　
<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Animal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token comment">//重点！！！！</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
<span class="token punctuation">}</span>


<span class="token keyword">var</span> proto <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token comment">//重点！！！！</span>
proto<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token comment">//重点！！！！</span>
Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> proto<span class="token comment">//重点！！！！</span>

<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span> <span class="token comment">//动物</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token comment">//[&quot;运动&quot;, &quot;繁殖&quot;]</span>
</code></pre><h3 id="核心-6"><a href="#核心-6" aria-hidden="true" class="header-anchor">#</a> 核心</h3><p>用object(Animal.prototype)切掉了原型对象上多余的那份父类实例属性</p><h3 id="优缺点-6"><a href="#优缺点-6" aria-hidden="true" class="header-anchor">#</a> 优缺点</h3><ul><li>优点：</li></ul><ol><li>几乎完美</li></ol><ul><li>缺点:</li></ul><ol><li>用起来有些麻烦，理论上没有缺点。</li></ol><h2 id="es5使用-object-create-创建对象"><a href="#es5使用-object-create-创建对象" aria-hidden="true" class="header-anchor">#</a> ES5使用 Object.create 创建对象</h2><p>ECMAScript 5 中引入了一个新方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener noreferrer">Object.create()
</a>。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create方法时传入的第一个参数：</p><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token comment">// a ---&gt; Object.prototype ---&gt; null</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 (继承而来)</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span>

<span class="token keyword">var</span> d <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// d ---&gt; null</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined, 因为d没有继承Object.prototype</span>
</code></pre><h2 id="es6使用-class-关键字"><a href="#es6使用-class-关键字" aria-hidden="true" class="header-anchor">#</a> ES6使用 class 关键字</h2><p>ECMAScript6 引入了一套新的关键字用来实现 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener noreferrer">class</a>。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="noopener noreferrer">class
</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor" target="_blank" rel="noopener noreferrer">constructor
</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/static" target="_blank" rel="noopener noreferrer">static
</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends" target="_blank" rel="noopener noreferrer">extends
</a>, 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super" target="_blank" rel="noopener noreferrer">super
</a>.
例子如下：</p><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>species<span class="token punctuation">,</span> canDo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">'动物'</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>canDo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'运动'</span><span class="token punctuation">,</span> <span class="token string">'繁殖'</span><span class="token punctuation">]</span>　
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'小黄'</span><span class="token punctuation">,</span> <span class="token string">'黄色'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>cat1<span class="token punctuation">)</span>
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/4337988-fb5013616b04ead4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="参考文献"><a href="#参考文献" aria-hidden="true" class="header-anchor">#</a> 参考文献</h2><ul><li><p><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener noreferrer">JavaScript高级程序设计（第3版）6.3继承</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener noreferrer">阮一峰博客-Javascript面向对象编程（二）：构造函数的继承</a></p></li><li><p><a href="http://www.cnblogs.com/ayqy/p/4471638.html" target="_blank" rel="noopener noreferrer">重新理解JS的6种继承方式</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="noopener noreferrer">MDN-Class</a></p></li></ul></div><!----><div class="content page-nav"><p class="inner"><!----><span class="next"><a href="/BrownHu/blog/JavaScript/JavaScript的三种事件模型.html">
          JavaScript的三种事件模型
        </a> →
      </span></p></div></div></div></div>
    <script src="/BrownHu/assets/js/32.ca616d80.js" defer></script><script src="/BrownHu/assets/js/app.a914753b.js" defer></script>
  </body>
</html>
